#include <iostream>

using namespace std;

//服务器模型
//C/S模型
//所有客户端都通过访问服务器来获取所需的资源

//P2P模型
//让每台机器在消耗服务的同时也给别人提供服务

//两种高效的事件处理模式
//Reactor模式
//要求主线程只负责监听文件描述符上是否有事件发生，有的话立即将该事件通知工作线程，除此之外，主线程不做任何其他实质性的工作。
//读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。
//使用同步IO模型实现的Reactor模式的工作流程：
//1、主线程往epoll内核事件表中注册socket上的读就绪事件
//2、主线程调用epoll_wait等待socket上有数据可读
//3、当socket上有数据可读时，epoll_wait通知主线程，主线程则将socket可读事件放入请求队列。
//4、睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。
//5、主线程调用epoll_wait等待socket可写
//6、当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列。
//7、睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户端请求的结果。

//Proactor模式
//Proactor模式将所有IO操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。
//1、主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序
//2、主线程继续处理其他逻辑
//3、当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。
//4、应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求，工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，
//并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。
//5、主线程继续处理其他逻辑
//6、当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。
//7、应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理

//模拟Proactor模式
//使用同步IO模型模拟出的Proactor模式的工作流程如下
//1、主线程往epoll内核事件表中注册socket上的读就绪事件
//2、主线程调用epoll_wait等待socket上有数据可读
//3、当socket上有数据可读，epoll_wait通知主线程，主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。
//4、睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件
//5、主线程调用epoll_wait等待socket可写
//6、当socket可写时，epoll_wait通知主线程，主线程往socket上写入服务器处理客户请求的结果

//并发模式是指IO处理单元和多个逻辑单元之间协调完成任务的方法，主要有2种并发编程模式：半同步/半异步模式 和 领导者/追随者模式

//半同步/半异步模式
//IO模型中，同步和异步区分的是内核向应用程序通知的是何种IO事件，以及该由谁来完成IO读写
//并发模式中，同步指的是程序完全按照代码序列的顺序执行，异步指的是程序的执行需要由系统事件来驱动。
//半同步/半异步模式中，同步线程用于处理客户逻辑，异步线程用于处理IO事件

//领导者/追随者模式
//领导者/追随者模式是多个工作线程轮流获得事件源集合，轮流监听，分发并处理事件的一种模式。
//在任意时间点，程序都仅有一个领导者线程，它负责监听IO事件，而其他线程则都是追随者，它们休眠在线程池中等待成为新的领导者。
//当前的领导者如果检测到IO事件，首先要从线程池中推选出新的领导者线程，然后处理IO事件，此时，新的领导者等待新的IO事件，原来的领导者则处理IO事件，二者实现了并发。

//有限状态机

//状态独立的有限状态机
//状态机的每个状态都是相互独立的，没有相互转移
//STATE_MACHINE(Package _pack) {
//    PackageType _type = _pack.GetType();
//    switch(_type) {
//        case type_a:
//            process_package_a(_pack);
//            break;
//        case type_b:
//            process_package_b(_pack);
//            break;
//    }
//}

//带状态转移的有限状态机
//
//STATE_MACHINE() {
//    State cur_state = type_a;
//    while(cur_state != type_c) {
//        Package _pack = getNewPackage();
//        switch(cur_state) {
//            case type_a:
//                process_package_a(_pack);
//                cur_state = type_b;
//                break;
//            case type_b:
//                process_package_b(_pack);
//                cur_state = type_c;
//                break;
//        }
//    }
//}

//提高服务器性能的其他建议
//池
//池是一组资源的集合，在服务器启动之初就被完全创建好并初始化，需要时直接从池中获取，处理完后，把资源放回池中。
//常见的有，内存池，进程池，线程池，连接池

//数据复制
//避免不必要的数据复制，2个工作进程之间要传递大量的数据时，考虑使用共享内存来在它们之间直接共享这些数据

//上下文切换
//进程切换和线程切换导致的系统开销，使用过多的工作线程，线程间的切换将占用大量的CPU时间

//锁
//共享资源的加锁保护，如果必须使用锁，则可以考虑减小锁的粒度，比如使用读写锁。

int main() {
    return 0;
}
