#include <iostream>
#include <unistd.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <arpa/inet.h>
using namespace std;

//（1）网络接口和物理层（有时也可称为链路层）是 TCP/IP 的最底层，负责将二进制流转换为 数据帧，并进行数据帧的发送和接收。数据帧是网络传输的基本单元。
//（2）网络层负责在主机之间的通信中选择数据包的传输路径，即路由。当网络层接收传输层的 请求后，传输某个具有目的地址信息的分组。
//该层把分组封装在 IP 数据包中，填入数据包的首部， 使用路由算法来确定是直接交付数据包，还是把它传递给路由器，最后把数据包交给适当的网络接 口进行传输。
//网络层同时负责处理传入的数据包。检验其有效性，使用路由算法来决定应该对数据包进行 本地处理还是转发。
//如果数据包目的机处于本机所在的网络，该层软件就会除去数据包的首部， 再进行适当的传输层协议来处理这个分组。
//最后，网络层还要根据需要发出和接收 ICMP 差错和控 制报文。
//（3）传输层负责实现应用程序之间的通信服务，这种通信又称为端到端通信。传输层要系统地 管理信息的流动。还要提供可靠的传输服务。
//以确保数据到达无差错、无失序。为了达到这个目的， 传输层协议软件要进行协商，让接收方回送确认信息及让发送方重发丢失的分组。
//传输层协议软件 把要传输的数据流划分为分组，把每个分组连同目的地址交给网络层去发送。
//（4）应用层是分层模型的最高层。应用程序使用相应的应用层协议，把封装好的数据提交给传输层，或从传输层接收数据并处理。

//TCP/IP 模型特点
//（1）TCP/IP 分层模型边界特性。TCP/IP 分层模型中有两大边界特性：一个是地址边界特性，它将 IP逻辑地址与底层网络的硬件地址分开；另一个是操作系统边界特性，它将网络应用与协议软件分开。
//（2）IP 层特性。IP 层向上层提供统一的 IP 包，使得各种网络帧或包格式的差异性对高层协议不复存在。IP 层是 TCP/IP 实现异构网互联最关键的一层。
//（3）TCP/IP 的可靠性特性。TCP 提供面向连接的服务，因为传输层是端到端的，所以TCP/IP 的可靠性被称为端到端可靠性。

//TCP 与 UDP
//1．相同点
//二者同为传输层协议。

//2．不同点
//TCP 是一种面向连接的传输层协议，它能提供高可靠性通信（数据无误、数据无丢失、 数据无 失序、数据无重复到达的通信）。
//TCP 适用于对传输质量要求较高，以及传输大量数据的通信；在 需要可靠数据传输的场合，通常使用 TCP。常见使用 TCP 的应用有浏览器等。
//TCP 的优点是可靠。稳定的 TCP 的可靠性体现在 TCP在传输数据之前，会有三次握手来建立连接，而且在数据传递时，有确认机制、窗口、重传机制、阻塞控制机制，在数据传完后，还会断开连接，以节约系统资源。
//TCP 的缺点也很明显，具体包括传输慢、效率低、占用系统资源高以及易被攻击。
//TCP在传输数据之前，要先建立连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、阻塞控制机制等会消耗大量时间。
//UDP 是一种不可靠的无连接的协议。因为不需要连接，所以可以进行高效率的数据传输。
//UDP适用于对网络通信质量要求不高、网络通信速度尽量快的通信。常见的 UDP 的应用有 QQ语音、QQ 视频等。
//UDP 的优点是快，比 TCP 稍安全。UDP 没有 TCP 的握手机制、确认机制、窗口、重传机制、阻塞等控制机制。
//没有 TCP 的这些机制，UDP 较 TCP 被攻击者利用的漏洞就要少一些。UDP是一个无状态的传输协议，所以它在传输数据时非常快。
//UDP 的缺点是不可靠、 不稳定。 在数据传输时，如果网络质量不好，就容易丢包。

//套接字
//（1）流式套接字（SOCK_STREAM）。流式套接字提供了一个面向连接、可靠的数据传输服务，
//数据无差错、无重复的发送，且按发送顺序接收。 内设置流量控制，避免数据流淹没慢的接收方。 数据被看作是字节流，无长度限制。 TCP 通信使用的就是流式套接字。
//（2）数据报套接字（SOCK_DGRAM）。数据报套接字提供无连接服务。
//数据包以独立数据包的形式被发送，不提供无差错保证，数据可能丢失或重复，顺序发送，可能乱序接收。UDP通信使用的就是数据报套接字。
//（3）原始套接字（SOCK_RAW）。原始套接字允许对较低层次协议（如 IP、ICMP）进行直接访问。
//虽然它功能强大，但使用较为不便，主要用于一些协议的开发。

//IP 地址
//IP 地址是区分同一个网络中的不同主机的唯一标识。
//IP 地址为 32 位（IPv4，4 字节）或者 128 位（IPv6，16 字节）。通常使用点分十进制表示，如192.168.1.100。
//IP 地址被分为网络号和主机号两部分，网络号位数直接决定了可以分配的网络数，主机号位数则决定了网络中最大的主机数。
//IP 地址分为 A、B、C、D、E 5 类。
//（1）A 类地址。A 类 IP 地址是指，在 IP 地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码。
//如果用二进制表示 IP 地址的话，A 类 IP 地址就由1字节的网络地址和3字节主机地址组成。因此 A 类 IP 地址中网络的标识长度为8位，主机标识的长度为24位。
//A 类地址的子网掩码：255.0.0.0。
//（2）B 类地址。B 类 IP 地址是指，在 IP 地址的四段号码中，前两段号码为网络号码。
//如果用二进制表示 IP 地址的话，B 类 IP 地址就是由2字节的网络地址和2字节主机地址组成。B 类 IP地址中网络的标识长度为 16 位，主机标识的长度为 16 位。
//B 类地址的子网掩码：255.255.0.0。
//（3）C 类地址。C 类 IP 地址是指，在 IP 地址的四段号码中，前三段为网络号码，剩下的一段号码为本地计算机的号码。
//如果用二进制的表示 IP 地址的话，C 类 IP 地址就是由 3 字节的网络地 址和 1 字节的主机地址组成。C 类 IP 地址中网络的标识长度为 24 位，主机标识的长度为 8 位。
//C 类地址的子网掩码：255.255.255.0。
//（4）D 类地址。D 类 IP 地址在历史上被称为多播地址，即组播地址。
//在以太网中，多播地址命名了一组应该在这个网络中应用接收一个分组的站点，范围从 224.0.0.0 到 239.255.255.255。
//（5）E 类地址。E 类网络地址不分网络号和主机号，其范围为 240.0.0.0 到 247.255.255.255。
//E 类地址的第 1 个字节的前 5 为固定为 11110。E 类地址目前为保留状态，为以后使用。

//1．IP 地址转换函数
//IPv4 地址转换函数有 inet_aton()、inet_addr()和 inet_ntoa()。而 IPv4 和 IPv6 兼容的函数有inet_pton()和 inet_ntop()。
//in_addr_t inet_addr(const char *cp);   将点分十进制的 IP 地址转换为网络字节序IP地址
//int inet_aton(const char *cp, struct in_addr *inp);   将点分十进制 IP 地址转换为网络字节序 IP 地址
//char *inet_ntoa(struct in_addr in);   将网络字节序 IP 地址转换为点分十进制 IP地址

//2．IPv4 和 IPv6 兼容的函数
//int inet_pton(int af, const char *src, void *dst);
//可以被设置为 AF_INET（表示 IPv4）、AF_INET6（表示 IPv6）。
//const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);

void addr_test() {
    in_addr_t addr = inet_addr("127.0.0.1");
    printf("%x\n", addr);

    in_addr net_addr;
    inet_aton("127.0.0.1", &net_addr);
    printf("%x\n", net_addr.s_addr);

    char *str_addr = inet_ntoa(net_addr);
    printf("%s\n", str_addr);
}

void addr_test2() {
    in_addr addr;
    inet_pton(AF_INET, "127.0.0.1", &addr);
    printf("%x\n", addr.s_addr);

    char str[20];
    inet_ntop(AF_INET, &addr.s_addr, str, sizeof(str));
    printf("%s\n", str);
}

//TCP/IP 端口
//端口号使用 2 个字节（16 位），其范围是 0～65536。按照端口号可以将端口分为以下三大类。
//（1）公认端口：端口号 1～1023（1～255 为保留端口，256～1023 被 UNIX 系统占用）。
//（2）已登记端口：端口号 1024～49151，分配给用户进程或应用程序。
//（3）动态或私有端口：端口号 49152～65536，理论上不为服务分配这些端口。

//字节序
//字节序有两种：
//大端（高位字节存储在低位地址，低位字节存储在高位地址）和
//小端（高位字节存储在高位地址，低位字节存储在低位地址）。
//一般主机的字节序采用小端存储，而网络字节序采用大端存储。
void order_test() {
    int a = 0x12345678;
    char *p = (char *) &a;

    printf("*p = %x\n", *p);

    if (*p == 0x78) {
        printf("小端\n");
    } else {
        printf("大端\n");
    }
}

//字节序转换涉及函数字节序转换涉及 4 个函数：htons()、ntohs()、htonl()和 ntohl()。
//这里的 h代表 host，n 代表 network，s 代表 short，l 代表 long。

//将主机字节序转换为网络字节序
//uint32_t htonl(uint32_t hostlong);
//uint16_t htons(uint16_t hostshort);

//将网络字节序转换为主机字节序
//uint32_t ntohl(uint32_t netlong);
//uint16_t ntohs(uint16_t netshort);

int main() {
    //addr_test();
    //addr_test2();
    order_test();
    return 0;
}
